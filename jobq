#!/bin/sh

# Simple job queue, run one process at once per queue and log timings and delays.
#
# A jobqueue is a simple list of files as $JOBPATH/<queue-name>/<job-id>
# which content is a plain command to execute.

# Copyright (C) 2009 Bearstech - http://bearstech.com/
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

PROGRAM=jobq
VERSION=0.6-dev

# Hardcoded value for now, should fit most people
JOBPATH=/tmp/$PROGRAM-$LOGNAME


list_jobs() {
    cd $JOBPATH/$queue 2>/dev/null || exit 0
    echo "ID     Submission date      Command"
    ls -1rt | \
    while read job; do
        jobt=`stat -c%y $job | cut -d. -f1`
        printf "%5s %20s  " $job "$jobt"
        sed 's/\\\([^\]\)/\1/g' <$job
    done 
}

add_job() {
    set -e
    mkdir -m 0700 -p $JOBPATH/$queue
    cd $JOBPATH/$queue

    # Command line args re-quote - you don't want to know this shell ugliness.
    argv=
    for a in "$@"; do 
        qa=$(printf %q "$a")
        argv="$argv$qa "
    done

    # Hopefully this 'mv' is atomic, thus our joblist is lock-free
    id=$$
    echo "$argv" >.$id && mv .$id $id
  
    # Automatically start queue runner
    cd - >/dev/null && exec $0 -q $queue -d
}

queue_runner() {
    trap ":" INT HUP
    exec </dev/null 2>/dev/null >/dev/null

    while true; do
        # Fetch job list in time order, older is first
        jobl=`ls -1rt 2>/dev/null`
        job=`echo "$jobl" | head -n1`

        if [ -n "$job" ]; then
            cmd=`cat $job`              # content of job file, the command to run
            job=`basename "$job"`       # job ID
            jobt=`stat -c%Y $job`       # job submission time
            todo=`echo "$jobl" |wc -l`  # job queue size
            rm $job                     # remove the job, it _will_ be run in a few lines
            todo=$(( $todo - 1 ))

            # Run job in a subshell, capture stdin+stderr, send to syslog
            # FIXME: should support mail output like cron
            export jobt todo
            (
                t0=`date +%s`
                late=$(( $t0 - $jobt ))
                echo -n "start (delay:$late sec, todo:$todo): "
                echo "$cmd" | sed 's/\\\([^\]\)/\1/g'
                eval $cmd 2>&1
                ret=$?
                dt=$(( `date +%s` - $t0 ))
                echo "done (time:$dt sec, exit:$ret)"
            ) | logger -t "job[$job]"
        else
            # No job, re-scan the queue later
            sleep 5
        fi
    done
}

run_daemon() {
    cd $JOBPATH/$queue

    pidfile=.runner
    pid=`cat $pidfile 2>/dev/null`
    if kill -0 "$pid" 2>/dev/null; then
        # OK, queue runner is alive for this queue
        exit 0
    fi
    # No queue runner at all or some dead pid, cleanup
    rm -f $pidfile

    export queue pidfile
    queue_runner &

    pid=$!
    echo $pid > $pidfile
    echo "queue runner started for '$queue' (pid $pid)" | logger -t $PROGRAM
}

help() {
    cat << EOF
List queue: $PROGRAM [-q <queue>]
Submit job: $PROGRAM [-q <queue>] command args ...

The default queue is called, er, 'default'. One 'queue runner' daemon is
needed per queue, and is started automatically upon first job submission.
There is no mechanism to stop a queue runner besides killing it for now.

Options:
  -d, --daemon       Explicitly start queue runner daemon
  -h, --help         Show this help
  -q, --queue QUEUE  Select queue (default name is 'default')
  -v, --version      Show this software revision
EOF
    exit 1
}

version() {
    echo "$PROGRAM $VERSION"
    exit 0
}

queue=default

parse_opt=run
while [ $parse_opt != "done"  ] ; do
    case "$1" in
        -d|--daemon)  run_daemon;;
        -q|--queue)   shift; queue="$1"; shift;;
        -h|--help)    help;;
        -v|--version) version;;

        --) parse_opt=done;;
        -*) echo "$PROGRAM: unknown option $1, try -h for help" >&2; exit 2;;
         *) parse_opt=done;;
    esac
done


if [ $# -gt 0 ]; then
    add_job "$@"
else
    list_jobs
fi
